# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата
# «день-месяц-год». В рамках класса реализовать два метода. Первый, с декоратором @classmethod,
# должен извлекать число, месяц, год и преобразовывать их тип к типу «Число». Второй, с декоратором
# @staticmethod, должен проводить валидацию числа, месяца и года (например, месяц — от 1 до 12).
# Проверить работу полученной структуры на реальных данных.

class Date:
    def __init__(self, date_str):
        self.day, self.month, self.year = self.parse_date(date_str)

    @classmethod
    def parse_date(cls, date_str):
        day, month, year = map(int, date_str.split('-'))
        return day, month, year

    @staticmethod
    def validate_date(day, month, year):
        if not (1 <= month <= 12):
            raise ValueError("Месяц должен быть в диапазоне от 1 до 12")
        if day < 1 or day > 31:
            raise ValueError("День должен быть в диапазоне от 1 до 31")
        if year < 1:
            raise ValueError("Год должен быть положительным числом")
        if month == 2 and day > 29:
            raise ValueError("В феврале не может быть более 29 дней")
        if month in [4, 6, 9, 11] and day > 30:
            raise ValueError("В апреле, июне, сентябре и ноябре не может быть более 30 дней")


# Создание объекта и тестирование
try:
    date = Date("31-12-2021")
    print(f"День: {date.day}, Месяц: {date.month}, Год: {date.year}")
    Date.validate_date(date.day, date.month, date.year)
    print("Дата корректна.")
except ValueError as e:
    print(e)


# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на нуль. Проверьте его работу на
# данных, вводимых пользователем. При вводе пользователем нуля в качестве делителя программа должна корректно
# обработать эту ситуацию и не завершиться с ошибкой.

class DivisionByZeroError(Exception):
    """Класс исключения для обработки деления на нуль."""

    def __init__(self, message="Деление на ноль запрещено!"):
        self.message = message
        super().__init__(self.message)


def divide_numbers(a, b):
    """Функция для деления двух чисел, которая обрабатывает деление на нуль."""
    if b == 0:
        raise DivisionByZeroError
    return a / b


def main():
    while True:
        try:
            num1 = float(input("Введите числитель: "))
            num2 = float(input("Введите знаменатель: "))
            result = divide_numbers(num1, num2)
            print(f"Результат деления: {result}")
            break  # Выход из цикла, если деление прошло успешно
        except ValueError:
            print("Ошибка: Введено не числовое значение. Пожалуйста, попробуйте снова.")
        except DivisionByZeroError as e:
            print(e)


if __name__ == "__main__":
    main()


# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел.
# Проверить работу исключения на реальном примере. Необходимо запрашивать у пользователя данные и заполнять список.
# Класс-исключение должен контролировать типы данных элементов списка.

class NonNumericError(Exception):
    """Класс исключения, который срабатывает, если в список пытаются добавить не числовой элемент"""

    def __init__(self, message="Данные должны быть числовыми. Строки не допускаются."):
        self.message = message
        super().__init__(self.message)


def main():
    numbers = []

    while True:
        value = input("Введите число или 'stop' для завершения: ")
        if value.lower() == 'stop':
            break

        try:
            # Преобразование введенного значения в число
            number = float(value)
            numbers.append(number)
        except ValueError:
            # Если введенное значение не является числом, генерирация исключения
            try:
                raise NonNumericError
            except NonNumericError as e:
                print(e)

    print("Сформированный список чисел:", numbers)


if __name__ == "__main__":
    main()


# 4. Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад.
# А также класс «Оргтехника», который будет базовым для классов-наследников.
# Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс).
# В базовом классе определить параметры, общие для приведенных типов.
# В классах-наследниках реализовать параметры, уникальные для каждого типа оргтехники.

class Оргтехника:
    def __init__(self, модель, серийный_номер, год_выпуска):
        self.модель = модель
        self.серийный_номер = серийный_номер
        self.год_выпуска = год_выпуска


class Принтер(Оргтехника):
    def __init__(self, модель, серийный_номер, год_выпуска, тип_печати):
        super().__init__(модель, серийный_номер, год_выпуска)
        self.тип_печати = тип_печати


class Сканер(Оргтехника):
    def __init__(self, модель, серийный_номер, год_выпуска, разрешение_сканирования):
        super().__init__(модель, серийный_номер, год_выпуска)
        self.разрешение_сканирования = разрешение_сканирования


class Ксерокс(Оргтехника):
    def __init__(self, модель, серийный_номер, год_выпуска, скорость_копирования):
        super().__init__(модель, серийный_номер, год_выпуска)
        self.скорость_копирования = скорость_копирования


class Ноутбук(Оргтехника):
    def __init__(self, модель, серийный_номер, год_выпуска, тип_процессора):
        super().__init__(модель, серийный_номер, год_выпуска)
        self.тип_процессора = тип_процессора


# 5. Продолжить работу над первым заданием. Разработать методы, отвечающие за приём оргтехники
# на склад и передачу в определенное подразделение компании. Для хранения данных о наименовании
# и количестве единиц оргтехники, а также других данных, можно использовать любую подходящую структуру,
# например словарь.

class Склад:
    def __init__(self):
        self.техника_на_складе = {}
        self.подразделения = {}

    def добавить_технику(self, техника, количество):
        ключ = (техника.__class__.__name__, техника.модель)
        if ключ in self.техника_на_складе:
            self.техника_на_складе[ключ] += количество
        else:
            self.техника_на_складе[ключ] = количество
        print(f"Добавлено {количество} ед. {техника.модель} на склад.")

    def передать_технику(self, тип, модель, количество, подразделение):
        ключ = (тип, модель)
        if ключ in self.техника_на_складе and self.техника_на_складе[ключ] >= количество:
            self.техника_на_складе[ключ] -= количество
            print(f"Передано {количество} ед. {модель} в подразделение {подразделение}.")
            if подразделение in self.подразделения:
                if ключ in self.подразделения[подразделение]:
                    self.подразделения[подразделение][ключ] += количество
                else:
                    self.подразделения[подразделение][ключ] = количество
            else:
                self.подразделения[подразделение] = {ключ: количество}
        else:
            print(f"На складе недостаточно {модель} для передачи.")

    def показать_технику_на_складе(self):
        print("Техника на складе:")
        for (тип, модель), количество in self.техника_на_складе.items():
            print(f"{тип} {модель}: {количество} ед.")

    def показать_технику_в_подразделении(self, подразделение):
        if подразделение in self.подразделения:
            print(f"Техника в подразделении {подразделение}:")
            for (тип, модель), количество in self.подразделения[подразделение].items():
                print(f"{тип} {модель}: {количество} ед.")
        else:
            print(f"В подразделении {подразделение} нет техники.")


# Пример использования
склад = Склад()
склад.добавить_технику(Принтер("HP LaserJet 200", "12345", 2021, "лазерная"), 10)
склад.добавить_технику(Сканер("Canon Scan 3000", "54321", 2020, "1200dpi"), 5)
склад.передать_технику("Сканер", "Canon Scan 3000", 2, "Бухгалтерия")
склад.показать_технику_на_складе()
склад.показать_технику_в_подразделении("Бухгалтерия")


# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных.
# Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.

class Оргтехника:
    def __init__(self, модель, серийный_номер, год_выпуска):
        self.модель = модель
        self.серийный_номер = серийный_номер
        self.год_выпуска = год_выпуска

    def __str__(self):
        return f"{self.модель} ({self.серийный_номер}, {self.год_выпуска})"


class Принтер(Оргтехника):
    def __init__(self, модель, серийный_номер, год_выпуска, тип_печати):
        super().__init__(модель, серийный_номер, год_выпуска)
        self.тип_печати = тип_печати

    def __str__(self):
        return f"{super().__str__()}, тип печати: {self.тип_печати}"


class Склад:
    def __init__(self):
        self.техника_на_складе = {}
        self.подразделения = {}

    def добавить_технику(self, техника, количество):
        if not isinstance(количество, int) or количество < 1:
            raise ValueError("Количество должно быть положительным целым числом")
        ключ = (техника.__class__.__name__, техника.модель)
        if ключ in self.техника_на_складе:
            self.техника_на_складе[ключ] += количество
        else:
            self.техника_на_складе[ключ] = количество
        print(f"Добавлено {количество} ед. {техника} на склад.")

    def передать_технику(self, тип, модель, количество, подразделение):
        if not isinstance(количество, int) or количество < 1:
            raise ValueError("Количество должно быть положительным целым числом")
        ключ = (тип, модель)
        if ключ in self.техника_на_складе and self.техника_на_складе[ключ] >= количество:
            self.техника_на_складе[ключ] -= количество
            if подразделение in self.подразделения:
                if ключ in self.подразделения[подразделение]:
                    self.подразделения[подразделение][ключ] += количество
                else:
                    self.подразделения[подразделение][ключ] = количество
            else:
                self.подразделения[подразделение] = {ключ: количество}
            print(f"Передано {количество} ед. {модель} тип {тип} в подразделение {подразделение}.")
        else:
            raise ValueError("На складе недостаточно техники для передачи.")


# Пример использования
склад = Склад()
printer = Принтер("HP LaserJet 200", "12345", 2021, "лазерная")
try:
    склад.добавить_технику(printer, 10)
    склад.передать_технику("Принтер", "HP LaserJet 200", 5, "Бухгалтерия")
except ValueError as e:
    print(e)


# 7. Реализовать проект «Операции с комплексными числами». Создайте класс «Комплексное число»,
# реализуйте перегрузку методов сложения и умножения комплексных чисел. Проверьте работу проекта,
# создав экземпляры класса (комплексные числа) и выполнив сложение и умножение созданных экземпляров.
# Проверьте корректность полученного результата.

class КомплексноеЧисло:
    def __init__(self, a, b):
        self.a = a  # действительная часть
        self.b = b  # мнимая часть

    def __add__(self, other):
        return КомплексноеЧисло(self.a + other.a, self.b + other.b)

    def __mul__(self, other):
        # формула произведения: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
        new_a = self.a * other.a - self.b * other.b
        new_b = self.a * other.b + self.b * other.a
        return КомплексноеЧисло(new_a, new_b)

    def __str__(self):
        return f"{self.a} + {self.b}i"


# Создание экземпляров комплексных чисел
num1 = КомплексноеЧисло(1, 2)
num2 = КомплексноеЧисло(3, 4)

# Выполнение сложения
result_add = num1 + num2
print("Результат сложения:", result_add)

# Выполнение умножения
result_mul = num1 * num2
print("Результат умножения:", result_mul)
